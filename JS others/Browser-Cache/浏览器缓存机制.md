# 浏览器缓存机制

标签（空格分隔）： 浏览器缓存

---

## 200 from cache
> 这个是真的是从浏览器缓存拿过来的，Cache-Control的设定了max-age还没过期（Cache-Controll还有很多可选字段），或者Expires限期没过之类的。
其实实际上是并没有发请求的。200 from cache是一个伪请求。

- 对于Cache-Control我们可以在html里加上meta标签来给请求报头加上Cache-Control字段

## 304 not modify
> 当Cache-Control或者Expires的限定日期过去之后，浏览器就自然会发请求过去。问题是，当浏览器发送请求之后，服务器可以发现“你请求的这个文件没更新过，你之前就已经缓存它了。”对的，的确有这个功能。

> 这就涉及到if-Modified-Since和if-Unmodified-Since这两个头部。浏览器通常使用if-Modified-Since这个头部来发送一个Last Modified值（上一次修改时间）给服务器。服务器确认并没有修改过之后会返回304 not modified状态码。如果没有匹配上的话，返回412（Precondition Failed）状态码，那就从返回新的源文件给浏览器

- 讲真，如果有个傻×在服务器那边的源文件上多打几个回车。last Modified自然改变了（但是基本内容是不变的）。那么如果是这样的话，又能靠什么来判断这个文件是否有决定性的改变呢

> Etag是服务器端的一个在实体上的头部字段，服务器会通过某种算法（md5之类）把资源相应给客户端时会在其头部加上一个Etag的标识符。然后客户端会保存这个标识符，下一次发回去请求时一起发。主要功能是帮助判断在服务器端的资源到底有没有被修改。
客户端是通过if-None-Match这个请求头来发送这个资源的Etag标识。

---

## 设置的很大的max-age的静态资源
> 如果需要频繁更新。可能浏览器会因为max-age没到期所以一直在用浏览器缓存的版本。

- 解决方法： 可以在文件的url后面加类似Etag之类的标识。当资源更新的时候同时更新标识

---
## Tips
> 大多数浏览器F5刷新时都会自行加上“Cache-Control:max-age=0”的请求字段，如果选中url地址栏再回车则不会被强加。


