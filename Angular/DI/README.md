# Angular

---

## 依赖注入

> 依赖注入是`Angular`引入到`JavaScript`的一种设计模式

简单来说，依赖注入就是拿来解耦的，通过把依赖的模块实例作为参数传入另一个模块

---

``` JavaScript
// 比较不好的做法
Class A {
	constructor() {
		this.name = 'a'
	}
}

Class B {
	constructor() {
		this.name = 'b'
	}
}

Class C {
	constructor() {
		this.a = new A()
		this.b = new B()
	}
}

```

好的，我们完美地实现出这个效果，前提是在程序比较小的时候，因为你看。

如果我们把A的构造函数改变一下，多传一个参数。我们的C类同时也会惨遭毒手。因为在C类的构造函数里面调用了A的构造函数，导致我们把A、B和C类耦合在了一起。

---

``` JavaScript
// 比较好的做法
Class A {
	constructor() {
		this.name = 'a'
	}
}

Class B {
	constructor() {
		this.name = 'b'
	}
}

Class C {
	constructor(A, B) {
		this.a = A
		this.b = B
	}
}
```

可以看到我们把创建好的A和B的实例传入了C的构造函数，把构造的过程提升出来，于是我们如果对类A进行了修改的话，也并不会影响到C类，这就是依赖注入，简单地把A、B和C解耦。


---

## 又一个问题！

> 我们完美地利用依赖注入完成了解耦。这样我们的程序就显得十分健壮了。但是也还是存在问题————我们在创建C的时候，现在必须要同时创建一个A和一个B。

可能在程序比较小的时候还好，这些工作都还不复杂。但是当应用规模变大之后，维护它将变得惊险重重。

解决方法是有的，`Angular`的依赖注入框架帮我们解决了这个问题。


### 依赖注入框架做了什么？

> `Angular`提供的注入器，会自动帮你做完把你的依赖动态`new`出来的操作，而我们所要做的，就是简单地在构造函数里面声明需要依赖的模块，然后这些模块的创建工作就愉快地交给`Angular`的注入器就好了。

`Angular`的`@injectable`装饰器标识一个类可以被注入器实例化。我们使用这个装饰器之后，当这个类被其他模块所需要的时候，只需要在别的模块的构造函数的参数声明它，`Angular`的注入器便会自动实例化一个这个类。

具体的注入过程分为三步：

- 得到模块的依赖项
- 查找依赖项所对应的对象
- 执行时注入

### 得到模块的依赖项

`Angular`通过使用`Function.prototype.toString`这个方法，把函数字符串化，然后通过正则匹配获得这个函数的参数列表，从而获取依赖项。

### 查找对应对象

直接从缓存对象中通过模块名查找对应对象。

### 执行时注入

通过`fn.apply`把参数和上下文传入对应的构造函数。`new`出来依赖的模块。

---

## 通常的用法

> 在`Angular`中，通常我们会把`@injectable`装饰器用在`service`里面，把`service`挂载在组件或者模块的`providers`上面，这样做可以让这个模块的组件或者组件的子组件可以通过依赖注入获取到这些`service`，从而获取到数据
